---
phase: 05-market-context-and-operations
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/data/mock/operations.ts
  - src/components/ui/ImpactBadge.tsx
  - src/components/ui/SignalCard.tsx
  - src/sections/operations/OperationalIntelligence.tsx
  - src/sections/operations/SupplyChainSignals.tsx
  - src/sections/operations/ManufacturingCapacity.tsx
  - src/sections/operations/ProcurementShifts.tsx
  - src/sections/operations/RetailFootprint.tsx
autonomous: true

must_haves:
  truths:
    - "User sees supply chain signals as color-coded cards indicating positive/negative/neutral impact per company"
    - "User sees manufacturing capacity changes with facility name, action badge (expansion/greenfield/rationalization/maintenance), investment amount, and timeline"
    - "User sees procurement shift signals with affected companies listed and impact description"
    - "User sees retail footprint changes with store count, geography, and expansion/rationalization/reformat action badge"
    - "All operational data is grouped by company using Radix Accordion, default-expanded"
    - "Company filter narrows displayed operational data to selected companies only"
    - "Procurement shifts (which use affectedCompanies array) are correctly filtered by company"
  artifacts:
    - path: "src/sections/operations/OperationalIntelligence.tsx"
      provides: "Main Operational Intelligence section with company-grouped accordion layout"
      min_lines: 60
    - path: "src/sections/operations/SupplyChainSignals.tsx"
      provides: "Supply chain signal cards with impact indicators"
      min_lines: 20
    - path: "src/sections/operations/ManufacturingCapacity.tsx"
      provides: "Manufacturing capacity cards with action badges"
      min_lines: 30
    - path: "src/sections/operations/ProcurementShifts.tsx"
      provides: "Procurement shift cards with affected companies"
      min_lines: 20
    - path: "src/sections/operations/RetailFootprint.tsx"
      provides: "Retail footprint cards with action badges and store counts"
      min_lines: 25
    - path: "src/components/ui/ImpactBadge.tsx"
      provides: "Positive/negative/neutral impact badge component"
      exports: ["ImpactBadge"]
    - path: "src/components/ui/SignalCard.tsx"
      provides: "Reusable operational signal card with impact coloring"
      exports: ["SignalCard"]
    - path: "src/data/mock/operations.ts"
      provides: "Mock data with company IDs matching COMPANIES[].id for correct filtering"
      contains: "amber"
  key_links:
    - from: "src/sections/operations/OperationalIntelligence.tsx"
      to: "src/hooks/use-filtered-data.ts"
      via: "useFilteredData('operations')"
      pattern: "useFilteredData.*operations"
    - from: "src/sections/operations/OperationalIntelligence.tsx"
      to: "radix-ui"
      via: "Radix Accordion for company grouping"
      pattern: "Accordion"
    - from: "src/data/mock/operations.ts"
      to: "src/data/mock/companies.ts"
      via: "company field values match COMPANIES[].id"
      pattern: "amber|dixon|havells|voltas|crompton|daikin|orient|bluestar|symphony|vguard"
---

<objective>
Build the Operational Intelligence section module -- per-company operational signals covering supply chain, manufacturing capacity, procurement shifts, and retail footprint changes, grouped by company in an accordion layout.

Purpose: Users need micro-level operational signals per company to identify BD opportunities (e.g., supply chain disruptions creating consulting demand, capacity expansions signaling growth strategy needs, retail rationalization indicating cost optimization needs).

Output: Fully rendered Operational Intelligence section replacing the Phase 2 placeholder, with company-grouped accordion containing 4 signal types, filterable via global company filter.
</objective>

<execution_context>
@/Users/prateekkurkanji/.claude/get-shit-done/workflows/execute-plan.md
@/Users/prateekkurkanji/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/05-market-context-and-operations/05-CONTEXT.md
@.planning/phases/05-market-context-and-operations/05-RESEARCH.md

@src/types/sections.ts
@src/data/mock/operations.ts
@src/data/mock/companies.ts
@src/hooks/use-filtered-data.ts
@src/lib/formatters.ts
@src/components/ui/StatCard.tsx
@src/components/ui/TrendIndicator.tsx
@src/components/ui/DataRecencyTag.tsx
@src/theme/tokens.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix mock data company IDs and create shared UI components</name>
  <files>src/data/mock/operations.ts, src/components/ui/ImpactBadge.tsx, src/components/ui/SignalCard.tsx</files>
  <action>
**CRITICAL: Fix company name-to-ID mismatch in mock data.**

The `useFilteredData` hook filters by comparing `entry.company` against company IDs from the filter store (e.g., "amber", "dixon", "havells"). The current mock data uses display names ("Amber Enterprises", "Dixon Technologies", "Havells India", etc.). The hook's `toLowerCase().replace(/\s+/g, "-")` fallback turns "Amber Enterprises" into "amber-enterprises" which does NOT match the company ID "amber". This means filtering silently fails.

**1. Update `src/data/mock/operations.ts`** -- change ALL `company` string fields to use the canonical company IDs from `COMPANIES[]` in `src/data/mock/companies.ts`:

| Current display name | Change to ID |
|---|---|
| "Amber Enterprises" | "amber" |
| "Dixon Technologies" | "dixon" |
| "Havells India" | "havells" |
| "Voltas" | "voltas" |
| "Daikin India" | "daikin" |
| "Crompton Greaves" | "crompton" |
| "Blue Star" | "bluestar" |
| "Orient Electric" | "orient" |
| "Havells" | "havells" |
| "V-Guard" | "vguard" |
| "Symphony" | "symphony" |

Apply this to ALL arrays:
- `supplyChainSignals[].company` -- "amber", "dixon", "havells", "voltas"
- `manufacturingCapacity[].company` -- "dixon", "amber", "daikin", "crompton"
- `procurementShifts[].affectedCompanies[]` -- ["voltas", "bluestar", "amber"], ["havells", "vguard"], ["symphony", "crompton"]
- `retailFootprint[].company` -- "havells", "bluestar", "orient", "crompton"

Keep ALL other data fields (signal text, details, amounts, timelines) exactly as-is. Only change the company identifier strings.

**2. Create `src/components/ui/ImpactBadge.tsx`:**

```typescript
import clsx from "clsx";

const config = {
  positive: { label: "Positive", className: "bg-positive/10 text-positive border-positive/20" },
  negative: { label: "Negative", className: "bg-negative/10 text-negative border-negative/20" },
  neutral:  { label: "Neutral",  className: "bg-neutral/10 text-neutral border-neutral/20" },
} as const;

interface ImpactBadgeProps {
  impact: "positive" | "negative" | "neutral";
  compact?: boolean;
}

export function ImpactBadge({ impact, compact }: ImpactBadgeProps) {
  const { label, className } = config[impact];
  return (
    <span className={clsx(
      "inline-flex items-center rounded border px-sm py-xs text-xs font-medium whitespace-nowrap",
      className,
    )}>
      {compact ? impact[0].toUpperCase() : label}
    </span>
  );
}
```

**3. Create `src/components/ui/SignalCard.tsx`:**

A reusable card for operational signals with left-border impact coloring:

```typescript
import clsx from "clsx";
import { ImpactBadge } from "./ImpactBadge";

const impactColors = {
  positive: "border-l-positive bg-positive/5",
  negative: "border-l-negative bg-negative/5",
  neutral:  "border-l-neutral bg-neutral/5",
};

interface SignalCardProps {
  title: string;
  detail: string;
  impact: "positive" | "negative" | "neutral";
  metadata?: string;
}

export function SignalCard({ title, detail, impact, metadata }: SignalCardProps) {
  return (
    <div className={clsx(
      "border-l-2 rounded p-md space-y-xs",
      impactColors[impact],
    )}>
      <div className="flex items-center justify-between gap-sm">
        <p className="text-sm font-medium text-text-primary">{title}</p>
        <ImpactBadge impact={impact} />
      </div>
      <p className="text-xs text-text-secondary leading-relaxed">{detail}</p>
      {metadata && (
        <p className="text-xs text-text-muted font-mono">{metadata}</p>
      )}
    </div>
  );
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` -- zero TypeScript errors. Verify that `operations.ts` mock data uses company IDs ("amber", "dixon", etc.) not display names. Verify ImpactBadge.tsx and SignalCard.tsx exist and export correctly.
  </verify>
  <done>Mock data company fields match COMPANIES[].id for correct filtering. ImpactBadge and SignalCard reusable UI components created.</done>
</task>

<task type="auto">
  <name>Task 2: Build Operational Intelligence section with company-grouped accordion</name>
  <files>src/sections/operations/OperationalIntelligence.tsx, src/sections/operations/SupplyChainSignals.tsx, src/sections/operations/ManufacturingCapacity.tsx, src/sections/operations/ProcurementShifts.tsx, src/sections/operations/RetailFootprint.tsx</files>
  <action>
Replace the Phase 2 placeholder in `OperationalIntelligence.tsx` with a company-grouped accordion layout containing 4 signal type sub-sections. The main component must retain `export default function OperationalIntelligence()` (React.lazy requires default export).

**OperationalIntelligence.tsx** (main orchestrator):

- Keep the existing `useFilteredData<OperationalIntelligenceData>("operations")` call, loading/error handling, and header with `DataRecencyTag`.
- Remove the placeholder content (record counts, active filters text, "Phase 5" italic text).
- Delete the `getActiveFilterSummary` helper function.
- Import `{ Accordion } from "radix-ui"` (unified package, already installed).
- Import `getCompanyById` from `src/data/mock/companies.ts` for resolving company IDs to display names.

**Company grouping logic** (implement in OperationalIntelligence.tsx or a local helper):

Create a `groupByCompany` function that takes the filtered `OperationalIntelligenceData` and groups all signals by company ID:

```typescript
interface CompanySignalGroup {
  id: string;
  name: string;
  supplyChain: OperationalIntelligenceData["supplyChainSignals"];
  manufacturing: OperationalIntelligenceData["manufacturingCapacity"];
  procurement: OperationalIntelligenceData["procurementShifts"];
  retail: OperationalIntelligenceData["retailFootprint"];
  totalSignals: number;
}
```

- `supplyChainSignals` and `manufacturingCapacity` and `retailFootprint` each have a `company` field (now an ID like "amber") -- group directly.
- `procurementShifts` have `affectedCompanies: string[]` (array of IDs) -- fan out: for each affected company, add the shift to that company's group. This means one procurement shift can appear under multiple company accordions.
- Use `getCompanyById(id)?.name ?? id` to resolve display names for accordion headers.
- Sort groups by `totalSignals` descending (companies with more signals first).

**Layout:**
```
<div className="p-md space-y-md">
  {/* Header row with title + DataRecencyTag */}
  {/* Summary row: total signal count */}
  <Accordion.Root type="multiple" defaultValue={groups.map(g => g.id)}>
    {groups.map(group => (
      <Accordion.Item key={group.id} value={group.id}>
        <Accordion.Header>
          <Accordion.Trigger className="flex items-center justify-between w-full p-md text-sm font-medium text-text-primary hover:bg-surface-raised transition-colors rounded">
            <span>{group.name}</span>
            <span className="text-xs text-text-muted">{group.totalSignals} signals</span>
          </Accordion.Trigger>
        </Accordion.Header>
        <Accordion.Content className="overflow-hidden data-[state=open]:animate-[accordion-open_200ms_ease-out] data-[state=closed]:animate-[accordion-close_200ms_ease-in]">
          <div className="space-y-md px-md pb-md">
            {group.supplyChain.length > 0 && <SupplyChainSignals signals={group.supplyChain} />}
            {group.manufacturing.length > 0 && <ManufacturingCapacity items={group.manufacturing} />}
            {group.procurement.length > 0 && <ProcurementShifts shifts={group.procurement} />}
            {group.retail.length > 0 && <RetailFootprint items={group.retail} />}
          </div>
        </Accordion.Content>
      </Accordion.Item>
    ))}
  </Accordion.Root>
</div>
```

Add accordion animation keyframes to `src/theme/tokens.css` if they don't exist:
```css
@keyframes accordion-open {
  from { height: 0; opacity: 0; }
  to { height: var(--radix-accordion-content-height); opacity: 1; }
}
@keyframes accordion-close {
  from { height: var(--radix-accordion-content-height); opacity: 1; }
  to { height: 0; opacity: 0; }
}
```

However, if adding to tokens.css causes issues with `@theme` scope, instead use inline Tailwind arbitrary animations or skip animation and rely on instant show/hide (functional correctness over animation polish).

Display an empty state message if no groups exist after filtering: "No operational signals match the current filters."

**SupplyChainSignals.tsx:**
- Props: `{ signals: OperationalIntelligenceData["supplyChainSignals"] }`
- Section heading: "Supply Chain" in `text-xs font-medium text-text-secondary uppercase tracking-wide`.
- Render each signal as a `SignalCard` with:
  - `title={signal.signal}` (the main signal text, truncate first ~80 chars if needed for title, full text in detail)
  - Actually, looking at the data: `signal.signal` is a long sentence. Better approach: use the first clause (up to first semicolon or ~60 chars) as title, and `signal.details` as detail.
  - `impact={signal.impact}`
  - `metadata` can be omitted or show a brief context.
- Wrap in `<div className="space-y-sm">`.

**ManufacturingCapacity.tsx:**
- Props: `{ items: OperationalIntelligenceData["manufacturingCapacity"] }`
- Section heading: "Manufacturing Capacity" in `text-xs font-medium text-text-secondary uppercase tracking-wide`.
- Render each item as a card (NOT using SignalCard -- capacity cards have different structure):

```typescript
const actionConfig = {
  expansion:       { label: "Expansion",       className: "bg-positive/10 text-positive" },
  greenfield:      { label: "Greenfield",      className: "bg-chart-1/10 text-chart-1" },
  rationalization: { label: "Rationalization",  className: "bg-negative/10 text-negative" },
  maintenance:     { label: "Maintenance",      className: "bg-neutral/10 text-neutral" },
};
```

Each card shows:
  - Facility name (text-sm font-medium)
  - Action badge (colored tag using actionConfig)
  - Investment amount formatted with `formatINRCr` from formatters.ts (skip if `investmentCr` is null)
  - Timeline text (text-xs text-text-muted)
- Card styling: `bg-surface-raised border border-surface-overlay rounded p-md`.

**ProcurementShifts.tsx:**
- Props: `{ shifts: OperationalIntelligenceData["procurementShifts"] }`
- Section heading: "Procurement Shifts" in `text-xs font-medium text-text-secondary uppercase tracking-wide`.
- Render each shift as a SignalCard-like card:
  - `title`: the `category` field (e.g., "Compressors")
  - `detail`: the `shift` description
  - `impact`: Map the `impact` string to positive/negative/neutral -- since the type is just `string`, determine impact sentiment: if it contains words like "savings", "improvement", "cost reduction" → "positive"; if "cost increase", "delay" → "negative"; otherwise → "neutral". OR simpler: just use "neutral" as default since the data type does not have a typed impact field. Use "neutral" for all procurement shifts.
  - Show `affectedCompanies` as a comma-joined list in metadata (resolve IDs to display names using `getCompanyById`).
- Wrap in `<div className="space-y-sm">`.

**RetailFootprint.tsx:**
- Props: `{ items: OperationalIntelligenceData["retailFootprint"] }`
- Section heading: "Retail Footprint" in `text-xs font-medium text-text-secondary uppercase tracking-wide`.
- Render each item as a card with:
  - Action badge similar to ManufacturingCapacity but for retail actions:
    ```typescript
    const retailActionConfig = {
      expansion:       { label: "Expanding",     className: "bg-positive/10 text-positive" },
      rationalization: { label: "Rationalizing", className: "bg-negative/10 text-negative" },
      reformat:        { label: "Reformatting",  className: "bg-neutral/10 text-neutral" },
    };
    ```
  - Store count: formatted as "{storeCount} stores" if not null
  - Geography text
  - Details paragraph
- Card styling: `bg-surface-raised border border-surface-overlay rounded p-md`.

**Important constraints:**
- Per-company data filterable via `useFilteredData` from Phase 2 (locked decision).
- Compact card-based layout with company grouping (locked decision).
- Use `getCompanyById` for all ID-to-name resolution -- do NOT inline company name lookups.
- Use `formatINRCr` for all investment amounts.
- Import Accordion from `"radix-ui"` (unified package) -- NOT from `@radix-ui/react-accordion`.
  </action>
  <verify>
Run `npx tsc --noEmit` -- zero TypeScript errors. Run `npm run dev` and navigate to the Operational Intelligence section. Verify:
1. Signals grouped by company in Radix Accordion sections, all default-expanded.
2. Each company accordion shows signal count in header.
3. Supply chain signals render as SignalCards with impact coloring.
4. Manufacturing capacity cards show facility, action badge, investment (INR Cr), timeline.
5. Procurement shifts show category, shift description, and affected companies.
6. Retail footprint cards show action badge, store count, geography, and details.
7. Activate company filter (e.g., select "Amber") -- only Amber's signals display. Other companies hidden.
8. Clear company filter -- all companies reappear.
  </verify>
  <done>Operational Intelligence section displays 4 signal types grouped by company in Radix Accordion. Company filtering works correctly (company IDs match). Requirements OPER-01, OPER-02, OPER-03, OPER-04 satisfied.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm run dev` shows Operational Intelligence section with company-grouped accordion
- Supply chain signals: Color-coded cards with impact badges (OPER-01)
- Manufacturing capacity: Cards with action badges, INR Cr investment, timeline (OPER-02)
- Procurement shifts: Category cards with affected company lists (OPER-03)
- Retail footprint: Cards with action badges, store counts, geography (OPER-04)
- Company filter narrows accordion to selected companies only
- Procurement shifts (affectedCompanies array) correctly appear under each affected company's accordion
- Empty state shown when no signals match active filters
</verification>

<success_criteria>
Operational Intelligence section renders 4 signal types (supply chain, manufacturing, procurement, retail) grouped by company in a Radix Accordion layout. Company filtering correctly narrows displayed data using canonical company IDs. Mock data company fields match COMPANIES[].id. Requirements OPER-01 through OPER-04 are complete.
</success_criteria>

<output>
After completion, create `.planning/phases/05-market-context-and-operations/05-02-SUMMARY.md`
</output>
