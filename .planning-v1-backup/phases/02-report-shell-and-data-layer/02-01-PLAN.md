---
phase: 02-report-shell-and-data-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/api/query-client.ts
  - src/api/client.ts
  - src/api/queries.ts
  - src/types/filters.ts
  - src/stores/filter-store.ts
  - src/stores/url-sync.ts
  - src/hooks/use-filtered-data.ts
  - src/data/mock/companies.ts
  - src/data/mock/executive.ts
  - src/data/mock/financial.ts
  - src/data/mock/market-pulse.ts
  - src/data/mock/deals.ts
  - src/data/mock/operations.ts
  - src/data/mock/leadership.ts
  - src/data/mock/competitive.ts
  - src/data/mock/deep-dive.ts
  - src/data/mock/action-lens.ts
  - src/data/mock/watchlist.ts
autonomous: true

must_haves:
  truths:
    - "API client fetches typed JSON fixtures with TanStack Query caching -- repeat calls return cached data without re-executing the loader"
    - "Zustand filter store manages companies (string[]), subCategory, performanceTier, and timePeriod with typed actions"
    - "Filter state syncs bidirectionally with URL search params -- setting a filter updates URL, navigating to a URL with params updates the store"
    - "useFilteredData hook combines cached section data with filter state via useMemo to produce filtered results without API refetch"
    - "Mock data contains 15+ real Indian Consumer Durables companies with plausible metrics across all 10 section fixtures"
  artifacts:
    - path: "src/api/query-client.ts"
      provides: "QueryClient singleton with Infinity staleTime for static mock data"
      exports: ["queryClient"]
    - path: "src/api/client.ts"
      provides: "fetchSectionData generic function reading from mock fixtures, swappable to real API"
      exports: ["fetchSectionData"]
    - path: "src/api/queries.ts"
      provides: "queryOptions factories for all 10 sections using co-located queryKey + queryFn"
      exports: ["sectionQueries"]
    - path: "src/types/filters.ts"
      provides: "FilterState interface and filter option types"
      exports: ["FilterState"]
    - path: "src/stores/filter-store.ts"
      provides: "Zustand store with filter state and typed actions"
      exports: ["useFilterStore"]
    - path: "src/stores/url-sync.ts"
      provides: "useFilterUrlSync hook for bidirectional URL <-> store sync"
      exports: ["useFilterUrlSync"]
    - path: "src/hooks/use-filtered-data.ts"
      provides: "Generic hook combining TanStack Query data + Zustand filters via useMemo"
      exports: ["useFilteredData"]
    - path: "src/data/mock/companies.ts"
      provides: "Company universe array with 15+ real Indian Consumer Durables companies"
      exports: ["COMPANIES", "SUB_SECTORS"]
    - path: "src/data/mock/financial.ts"
      provides: "FinancialPerformanceData fixture with typed company metrics"
      contains: "export default"
  key_links:
    - from: "src/api/client.ts"
      to: "src/data/mock/*.ts"
      via: "dynamic import mapping SectionId to fixture module"
      pattern: "import\\("
    - from: "src/api/queries.ts"
      to: "src/api/client.ts"
      via: "queryFn calls fetchSectionData"
      pattern: "fetchSectionData"
    - from: "src/hooks/use-filtered-data.ts"
      to: "src/stores/filter-store.ts"
      via: "useFilterStore selectors for filter state"
      pattern: "useFilterStore"
    - from: "src/hooks/use-filtered-data.ts"
      to: "src/api/queries.ts"
      via: "useQuery with sectionQueries factory"
      pattern: "useQuery.*sectionQueries"
---

<objective>
Build the data layer infrastructure: TanStack Query integration with typed API client reading from static JSON mock fixtures, Zustand filter store with bidirectional URL search param synchronization, and a useFilteredData hook that derives filtered results client-side without re-fetching.

Purpose: Establishes the entire data pipeline (fetch -> cache -> filter -> derive) that all 10 content modules will consume. Once this plan completes, any section component can call `useFilteredData('financial')` and receive typed, filtered data from cache.

Output: API client, query factories, filter store, URL sync hook, filtered data hook, and 10 realistic mock data fixtures.
</objective>

<execution_context>
@/Users/prateekkurkanji/.claude/get-shit-done/workflows/execute-plan.md
@/Users/prateekkurkanji/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-report-shell-and-data-layer/02-RESEARCH.md
@.planning/phases/02-report-shell-and-data-layer/02-CONTEXT.md
@.planning/phases/01-foundation-and-architecture/01-02-SUMMARY.md
@src/types/sections.ts
@src/types/common.ts
@src/types/company.ts
@src/types/financial.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies, create API client with TanStack Query, and mock data fixtures</name>
  <files>
    package.json
    src/api/query-client.ts
    src/api/client.ts
    src/api/queries.ts
    src/data/mock/companies.ts
    src/data/mock/executive.ts
    src/data/mock/financial.ts
    src/data/mock/market-pulse.ts
    src/data/mock/deals.ts
    src/data/mock/operations.ts
    src/data/mock/leadership.ts
    src/data/mock/competitive.ts
    src/data/mock/deep-dive.ts
    src/data/mock/action-lens.ts
    src/data/mock/watchlist.ts
  </files>
  <action>
    1. Install TanStack Query and Zustand:
       ```
       npm install @tanstack/react-query @tanstack/react-query-devtools zustand
       ```

    2. Create `src/api/query-client.ts`:
       - Export a `queryClient` singleton using `new QueryClient()`
       - Default options: `staleTime: Infinity` (mock data never goes stale), `gcTime: 1000 * 60 * 30` (30 min garbage collection), `refetchOnWindowFocus: false`, `refetchOnReconnect: false`, `retry: 1`

    3. Create `src/data/mock/companies.ts`:
       - Export `COMPANIES` array of `Company` objects (from `src/types/company.ts`) with 15-16 real Indian Consumer Durables companies:
         - Voltas (id: 'voltas', ticker: 'VOLTAS', subSector: 'Air Conditioning')
         - Blue Star (id: 'bluestar', ticker: 'BLUESTAR', subSector: 'Air Conditioning')
         - Havells India (id: 'havells', ticker: 'HAVELLS', subSector: 'Electrical Equipment')
         - Crompton Greaves (id: 'crompton', ticker: 'CROMPTON', subSector: 'Electrical Equipment')
         - Whirlpool India (id: 'whirlpool', ticker: 'WHIRLPOOL', subSector: 'Home Appliances')
         - Symphony (id: 'symphony', ticker: 'SYMPHONY', subSector: 'Air Conditioning')
         - Orient Electric (id: 'orient', ticker: 'ORIENTELEC', subSector: 'Electrical Equipment')
         - Bajaj Electricals (id: 'bajaj', ticker: 'BAJAJELEC', subSector: 'Electrical Equipment')
         - V-Guard Industries (id: 'vguard', ticker: 'VGUARD', subSector: 'Electrical Equipment')
         - TTK Prestige (id: 'ttk', ticker: 'TTKPRESTIG', subSector: 'Kitchen Appliances')
         - Butterfly Gandhimathi (id: 'butterfly', ticker: 'BUTTERFLY', subSector: 'Kitchen Appliances')
         - Amber Enterprises (id: 'amber', ticker: 'AMBER', subSector: 'Air Conditioning')
         - Dixon Technologies (id: 'dixon', ticker: 'DIXON', subSector: 'Electronics Manufacturing')
         - Johnson Controls-Hitachi (id: 'jch', ticker: 'JCHAC', subSector: 'Air Conditioning')
         - Daikin India (id: 'daikin', unlisted but include for coverage, subSector: 'Air Conditioning')
         - IFB Industries (id: 'ifb', ticker: 'IFBIND', subSector: 'Home Appliances')
       - Export `SUB_SECTORS` as `string[]` derived from unique subSector values in COMPANIES
       - Export a helper `getCompanyById(id: string): Company | undefined`

    4. Create 10 mock data fixture files in `src/data/mock/`, each exporting `default` matching the corresponding type from `src/types/sections.ts`:
       - Each fixture uses `dataAsOf: 'Q3 FY25'` and `lastUpdated: '2025-01-15T00:00:00Z'`
       - Use real company names from the COMPANIES array; reference them by name consistently
       - Financial data should be plausible but clearly mock (e.g., Voltas 18% revenue growth, Blue Star 21%, Havells 14%, etc.)
       - Each fixture should have 8-16 data entries to feel realistic -- enough for filtering to be meaningful
       - IMPORTANT: Each fixture file must `export default data` (not named export) because React.lazy and the API client use dynamic imports expecting default exports
       - See detailed fixture structure:
         - `executive.ts`: 5 bullets (themes like AC season demand, margin pressure from copper costs, PLI scheme impact, D2C channel growth, working capital stress), 4-5 red flags with company-specific signals
         - `financial.ts`: All 16 companies with FinancialMetrics, PerformanceLevel tags, variance analysis strings, and BSE/NSE source citations
         - `market-pulse.ts`: 4 demand signals, 4 input costs (steel, copper, plastics, aluminium), margin outlook narrative, 4 channel mix entries
         - `deals.ts`: 6-8 deals (mix of M&A, PE/VC, IPO, distressed types), 2-3 AI patterns
         - `operations.ts`: 4 supply chain signals, 4 manufacturing capacity entries, 3 procurement shifts, 4 retail footprint entries
         - `leadership.ts`: 4 CXO changes, 3 board reshuffles, 4 promoter stake changes, 2 auditor flags, 3 AI risk flags
         - `competitive.ts`: 5 product launches, 4 pricing actions, 3 D2C initiatives, 3 QC partnerships, 3 cluster analysis groups
         - `deep-dive.ts`: subSector 'Air Conditioning', 5 cost breakdown items, 4 margin levers, 3 top quartile metrics
         - `action-lens.ts`: persona 'PE/Investors', 4 takeaways, 4 signal scores
         - `watchlist.ts`: 3 fundraise signals, 3 margin inflection candidates, 3 consolidation targets, 4 stress indicators

    5. Create `src/api/client.ts`:
       - Export `fetchSectionData<T>(sectionId: SectionId): Promise<T>` generic async function
       - Internally maps SectionId to dynamic `import('../data/mock/...')` calls using a `Record<SectionId, () => Promise<{ default: unknown }>>` lookup
       - In dev mode (`import.meta.env.DEV`), add 200-500ms random delay to simulate network latency
       - The function returns the `.default` property of the imported module, cast to `T`
       - This abstraction is designed so that swapping to real API later means changing only this file: `return fetch(\`/api/sections/${sectionId}\`).then(r => r.json())`

    6. Create `src/api/queries.ts`:
       - Import `queryOptions` from `@tanstack/react-query`
       - Import `fetchSectionData` from `./client`
       - Import all 10 section data types from `src/types/sections.ts`
       - Export `sectionQueries` object with one method per section, each returning a `queryOptions({...})` call:
         ```
         sectionQueries.executive()   -> queryOptions({ queryKey: ['section', 'executive'], queryFn: ... })
         sectionQueries.financial()   -> queryOptions({ queryKey: ['section', 'financial'], queryFn: ... })
         ... (all 10)
         ```
       - Each uses `staleTime: Infinity` and `gcTime: Infinity` (static mock data, cache forever)
       - queryKeys must NOT include filter state (FOUND-14: client-side filtering, no refetch on filter change)
  </action>
  <verify>
    - `npm ls @tanstack/react-query zustand` shows both installed
    - `npx tsc --noEmit` passes with zero errors (all mock fixtures match their type contracts)
    - Quick manual check: import a fixture in a test or script and verify the shape matches the TypeScript interface
  </verify>
  <done>
    - TanStack Query v5 and Zustand v5 are in package.json dependencies
    - QueryClient singleton configured for static data caching (Infinity staleTime)
    - 16 companies defined in companies.ts with real Indian Consumer Durables names, tickers, and sub-sectors
    - 10 mock data fixture files exist, each with `export default` matching its section type interface
    - API client maps SectionId to fixture loaders with simulated latency in dev
    - queryOptions factories exist for all 10 sections with co-located queryKey + queryFn
    - TypeScript compiles with zero errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Zustand filter store with URL sync and useFilteredData hook</name>
  <files>
    src/types/filters.ts
    src/stores/filter-store.ts
    src/stores/url-sync.ts
    src/hooks/use-filtered-data.ts
  </files>
  <action>
    1. Create `src/types/filters.ts`:
       - Export `FilterState` interface:
         ```
         companies: string[]       // Company IDs (empty = all companies)
         subCategory: string       // Sub-sector filter ("all" = no filter)
         performanceTier: string   // "all" | "outperform" | "inline" | "underperform"
         timePeriod: string        // "QoQ" | "YoY" | "MoM"
         ```
       - Export `DEFAULT_FILTERS: FilterState` constant with `companies: []`, `subCategory: 'all'`, `performanceTier: 'all'`, `timePeriod: 'YoY'`
       - Export `FilterActions` interface with setter functions: `setCompanies`, `setSubCategory`, `setPerformanceTier`, `setTimePeriod`, `resetFilters`

    2. Create `src/stores/filter-store.ts`:
       - Import `create` from `zustand` and `subscribeWithSelector` from `zustand/middleware`
       - Import `FilterState`, `FilterActions`, `DEFAULT_FILTERS` from `../types/filters`
       - Create store using Zustand v5 double-parens TypeScript pattern: `create<FilterState & FilterActions>()(subscribeWithSelector((set) => ({...})))`
       - Each setter replaces its field: `setCompanies: (companies) => set({ companies })`
       - `resetFilters` sets all fields back to `DEFAULT_FILTERS`
       - Export as `useFilterStore`

    3. Create `src/stores/url-sync.ts`:
       - Export `useFilterUrlSync()` hook that establishes bidirectional sync between Zustand store and URL search params
       - Use `useSearchParams` from `react-router` for URL access
       - URL param mapping (per user decision):
         - `companies` -> comma-separated company IDs (omit param when empty = all companies)
         - `subcat` -> sub-category value (omit when 'all')
         - `tier` -> performance tier (omit when 'all')
         - `period` -> time period (omit when 'YoY' = default)
       - Use ref-based guards (`isUpdatingFromUrl` and `isUpdatingFromStore`) to prevent infinite loops between URL -> Store and Store -> URL directions
       - URL -> Store direction: `useEffect` watching `searchParams`, parses params into FilterState and calls `useFilterStore.setState()`
       - Store -> URL direction: `useEffect` with `useFilterStore.subscribe()` using `subscribeWithSelector`, converts filter state to URLSearchParams and calls `setSearchParams(params, { replace: true })`
       - Use `JSON.stringify` equality check in subscribe to avoid unnecessary URL updates
       - IMPORTANT: Do NOT use Zustand persist middleware for this -- persist serializes as single JSON key, but we need individual URL params per user decision

    4. Create `src/hooks/use-filtered-data.ts`:
       - Export `useFilteredData<T extends SectionData>(sectionId: SectionId)` generic hook
       - Internally calls `useQuery(sectionQueries[sectionId]())` to get cached section data
       - Reads filter state from `useFilterStore` using individual primitive selectors (NOT object selector -- prevents Zustand v5 infinite re-renders)
       - Uses `useMemo` to derive filtered data from raw cached data + filter state:
         - If `companies` is non-empty, filter any array fields that have a `company` or `id` property to only include matching companies
         - If `performanceTier` is not 'all', filter arrays that have a `performance` property
         - subCategory filtering: filter entries whose company's subSector matches (look up company in COMPANIES array)
         - timePeriod: passed through for display purposes (sections use it for chart period selection)
       - Returns `{ data: filteredData, rawData: originalData, isPending, error, filters }` where `filters` includes the current filter state
       - IMPORTANT: filtering happens in useMemo, NOT in useEffect+setState -- synchronous derived data, no extra renders
       - IMPORTANT: filter state must NOT appear in queryKeys -- data is fetched once and filtered client-side (FOUND-14)
  </action>
  <verify>
    - `npx tsc --noEmit` passes with zero errors
    - Filter store can be imported and used: `useFilterStore.getState()` returns DEFAULT_FILTERS
    - URL sync hook types check correctly with react-router's useSearchParams
  </verify>
  <done>
    - FilterState type and DEFAULT_FILTERS constant exported from src/types/filters.ts
    - Zustand filter store with subscribeWithSelector middleware exports useFilterStore
    - useFilterUrlSync hook provides bidirectional URL <-> store sync with infinite loop guards
    - useFilteredData hook combines TanStack Query cache with filter state via useMemo
    - No filter state in queryKeys (FOUND-14 compliance)
    - All files compile with zero TypeScript errors
  </done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` -- zero errors across all new files
2. Run `npm ls @tanstack/react-query zustand` -- both installed
3. Verify mock data fixtures match type contracts by checking TypeScript compilation
4. Verify filter store default state: companies=[], subCategory='all', performanceTier='all', timePeriod='YoY'
</verification>

<success_criteria>
- TanStack Query v5 and Zustand v5 installed and configured
- API client fetches typed mock data for all 10 sections with simulated latency
- queryOptions factories co-locate queryKey and queryFn for each section
- 16 real Indian Consumer Durables companies defined with sub-sectors
- 10 mock data fixture files with plausible, realistic data
- Zustand filter store manages 4 filter dimensions with typed actions
- URL sync hook provides bidirectional filter <-> URL param sync
- useFilteredData hook derives filtered data via useMemo without API refetch
- TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-report-shell-and-data-layer/02-01-SUMMARY.md`
</output>
