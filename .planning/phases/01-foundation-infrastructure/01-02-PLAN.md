---
phase: 01-foundation-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - dashboard_build_v2/src/data/loaders/consolidated.ts
  - dashboard_build_v2/src/data/loaders/screener.ts
  - dashboard_build_v2/src/data/loaders/sovrenn.ts
  - dashboard_build_v2/src/data/loaders/trendlyne.ts
  - dashboard_build_v2/src/data/loaders/financial-api.ts
  - dashboard_build_v2/src/data/loaders/news.ts
  - dashboard_build_v2/src/data/companies.ts
  - dashboard_build_v2/src/stores/filter-store.ts
  - dashboard_build_v2/src/stores/url-sync.ts
  - dashboard_build_v2/src/api/query-client.ts
  - dashboard_build_v2/src/api/queries.ts
  - dashboard_build_v2/src/hooks/use-filtered-data.ts
autonomous: true

must_haves:
  truths:
    - "Data loaders import JSON from @data alias and export typed accessor functions"
    - "Company registry provides lookup by ID, ticker, or display name for all 16 companies"
    - "Filter store manages 4 filter dimensions with Zustand v5 subscribeWithSelector"
    - "URL sync bidirectionally syncs filter state to URL search params without loops"
    - "TanStack Query client configured with staleTime:Infinity and no refetch"
    - "useFilteredData hook combines query data with Zustand filters using individual primitive selectors"
  artifacts:
    - path: "dashboard_build_v2/src/data/loaders/consolidated.ts"
      provides: "Typed access to consolidated-dashboard-data.json"
      contains: "import.*@data"
    - path: "dashboard_build_v2/src/data/companies.ts"
      provides: "Company registry with 16 companies"
      exports: ["COMPANIES", "getCompanyById", "getCompanyByTicker"]
    - path: "dashboard_build_v2/src/stores/filter-store.ts"
      provides: "Zustand filter store"
      exports: ["useFilterStore"]
    - path: "dashboard_build_v2/src/stores/url-sync.ts"
      provides: "Bidirectional URL sync hook"
      exports: ["useFilterUrlSync"]
    - path: "dashboard_build_v2/src/api/query-client.ts"
      provides: "TanStack Query client with staleTime:Infinity"
      exports: ["queryClient"]
    - path: "dashboard_build_v2/src/hooks/use-filtered-data.ts"
      provides: "Combined query + filter hook"
      exports: ["useFilteredData"]
  key_links:
    - from: "dashboard_build_v2/src/data/loaders/consolidated.ts"
      to: "@data/consolidated-dashboard-data.json"
      via: "static JSON import"
      pattern: "import.*@data/consolidated"
    - from: "dashboard_build_v2/src/hooks/use-filtered-data.ts"
      to: "dashboard_build_v2/src/stores/filter-store.ts"
      via: "Zustand primitive selectors"
      pattern: "useFilterStore\\(s => s\\."
    - from: "dashboard_build_v2/src/stores/url-sync.ts"
      to: "dashboard_build_v2/src/stores/filter-store.ts"
      via: "subscribeWithSelector"
      pattern: "useFilterStore\\.subscribe"
---

<objective>
Build the complete data layer (JSON loaders + company registry) and state management infrastructure (filter store, URL sync, query client, filtered data hook).

Purpose: This is the data backbone. Every section component will call useFilteredData() to get filtered, cached data. Without this, sections have nothing to render.
Output: Working data pipeline from JSON files through loaders, query cache, filter store, and into the useFilteredData hook.
</objective>

<execution_context>
@C:/Users/rohit/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rohit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md

# V1 reference files (carry forward patterns)
@src/stores/filter-store.ts
@src/stores/url-sync.ts
@src/api/query-client.ts
@src/api/queries.ts
@src/hooks/use-filtered-data.ts

# Data source files to understand shapes
@consumer-durables-intelligence/data_sources/extracted/consolidated-dashboard-data.json
@consumer-durables-intelligence/data_sources/extracted/screener-all-companies.json
@consumer-durables-intelligence/data_sources/extracted/sovrenn-intelligence.json
@consumer-durables-intelligence/data_sources/extracted/trendlyne-summary.json
@consumer-durables-intelligence/data_sources/extracted/financial-api-data.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create data loaders and company registry</name>
  <files>
    dashboard_build_v2/src/data/loaders/consolidated.ts
    dashboard_build_v2/src/data/loaders/screener.ts
    dashboard_build_v2/src/data/loaders/sovrenn.ts
    dashboard_build_v2/src/data/loaders/trendlyne.ts
    dashboard_build_v2/src/data/loaders/financial-api.ts
    dashboard_build_v2/src/data/loaders/news.ts
    dashboard_build_v2/src/data/companies.ts
  </files>
  <action>
    Create data loaders that import JSON at build time via the @data Vite alias (DATA-01). Each loader:
    1. Imports the raw JSON file with `import rawData from '@data/filename.json'`
    2. Defines TypeScript interfaces matching the JSON shape (read the actual JSON files to determine shapes)
    3. Exports a typed accessor function (e.g., `getConsolidatedData()`)
    4. Handles missing/malformed data gracefully — returns empty arrays, never throws (DATA-04)

    **consolidated.ts:** Import consolidated-dashboard-data.json. The file has shape `{ companies: [{ id, name, ticker, overview: { marketCapCr, currentPrice, ... }, quarterlyResults: [...], annualResults: [...], ratios: [...], balanceSheet: [...], ... }] }`. Export `getConsolidatedData()` returning `{ companies: ConsolidatedCompany[] }`. Export `getConsolidatedCompany(id: string)` for single company lookup. Define ConsolidatedCompany interface based on actual JSON shape.

    **screener.ts:** Import screener-all-companies.json. The file has shape `{ companies: { voltas: { company: {...}, key_metrics: {...}, quarterly_results: [...], ... } } }` — keyed by company ID. Export `getScreenerData()` and `getScreenerCompany(id: string)`. Use normalizeCompanyId from lib/company-matching.ts to map keys.

    **sovrenn.ts:** Import sovrenn-intelligence.json. The file is an array: `[{ companyId, companyName, description, clients, keyGrowthTriggers, quarterlyResults, dealActivity }]`. Export `getSovrennData()` and `getSovrennCompany(id: string)`.

    **trendlyne.ts:** Import trendlyne-summary.json. Shape: `{ companies: [{ companyId, companyName, nseSymbol, sector, latestQuarter, ... }] }`. Export `getTrendlyneData()` and `getTrendlyneCompany(id: string)`.

    **financial-api.ts:** Import financial-api-data.json. Shape: `{ section, dataAsOf, companies: [{ id, metrics, performance, history }] }`. This is the closest to v1's section data shape. Export `getFinancialApiData()`.

    **news.ts (NEWS-02, NEWS-07):** This loader will import news data when available. For now, create the module structure with a fallback to empty array. Export `loadNewsItems(): NewsItem[]` that filters out low-credibility sources (NEWS-02: anti-clickbait filtering at data layer). Export `getNewsForSection(sectionId: SectionId): NewsItem[]` that filters by sectionIds field. Export `getNewsForCompany(companyId: string): NewsItem[]`. Export helper functions: `isCorroborated(item: NewsItem): boolean` (NEWS-03), `isContradicted(item: NewsItem): boolean` (NEWS-04). When news data file doesn't exist, return empty arrays — never throw.

    **companies.ts:** Create the master company registry for all 16 companies. Define each company with: id, name, ticker, nseSymbol, subSector. Data comes from reading consolidated-dashboard-data.json and cross-referencing other sources. Export `COMPANIES: Company[]`, `getCompanyById(id: string): Company | undefined`, `getCompanyByTicker(ticker: string): Company | undefined`, `getCompanyByName(name: string): Company | undefined`. The 16 companies: amber, bajaj, bluestar, butterfly, crompton, daikin, dixon, havells, ifb, jch, orient, symphony, ttk, vguard, voltas, whirlpool. Note: daikin and jch may not be in all data files — include them in registry with whatever data is available.
  </action>
  <verify>
    Run `cd dashboard_build_v2 && npx tsc --noEmit` — all loader files should type-check.
    Verify each loader can be imported without runtime errors by checking that the JSON files exist at the @data paths.
    Check that news.ts returns empty array when no news data file exists (graceful degradation).
  </verify>
  <done>
    All 6 data loaders import their respective JSON files and export typed accessor functions. Company registry covers all 16 companies with lookup by ID, ticker, or name. News loader has anti-clickbait filtering and graceful degradation for missing data.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create state management and data hooks</name>
  <files>
    dashboard_build_v2/src/stores/filter-store.ts
    dashboard_build_v2/src/stores/url-sync.ts
    dashboard_build_v2/src/api/query-client.ts
    dashboard_build_v2/src/api/queries.ts
    dashboard_build_v2/src/hooks/use-filtered-data.ts
  </files>
  <action>
    **filter-store.ts (DATA-02):** Port verbatim from v1 (src/stores/filter-store.ts). Uses `create<FilterState & FilterActions>()(subscribeWithSelector(...))` pattern. Imports FilterState, FilterActions, DEFAULT_FILTERS from types/filters. 4 filter dimensions: companies, subCategory, performanceTier, timePeriod. Actions: setCompanies, setSubCategory, setPerformanceTier, setTimePeriod, resetFilters.

    **url-sync.ts:** Port verbatim from v1 (src/stores/url-sync.ts). Uses useSearchParams + useFilterStore.subscribe with ref guards to prevent infinite loops. PARAM_MAP: companies -> "companies", subCategory -> "subcat", performanceTier -> "tier", timePeriod -> "period". Export `useFilterUrlSync()` hook.

    **query-client.ts (DATA-03):** Port verbatim from v1 (src/api/query-client.ts). QueryClient with staleTime: Infinity, gcTime: 30 min, refetchOnWindowFocus: false, refetchOnReconnect: false, retry: 1. Do NOT include ReactQueryDevtools in production — this is for a presentation build.

    **queries.ts:** Create query option factories for each section. Unlike v1 which fetched from an API, v2 loads data synchronously from imported JSON via loaders. Each query factory returns `queryOptions({ queryKey: ['section', sectionId], queryFn: () => buildSectionData(sectionId) })`. For now, create a placeholder buildSectionData function that returns data from the financial-api loader (the closest to section shape). Section-specific adapters will be built in Phase 2 plans. Export `sectionQueries` record keyed by SectionId.

    **use-filtered-data.ts:** Port from v1 (src/hooks/use-filtered-data.ts) with one change: import getCompanyById from `../data/companies` instead of `../data/mock/companies`. Keep the individual primitive selectors pattern (useFilterStore(s => s.companies), etc.) to prevent Zustand v5 re-render loops. Keep the useMemo filtering logic that walks each array field and applies company/subCategory/performanceTier filters. Export `useFilteredData<T extends SectionData>(sectionId: SectionId)` returning { data, rawData, isPending, error, filters }.
  </action>
  <verify>
    Run `cd dashboard_build_v2 && npx tsc --noEmit` — all store and hook files should type-check.
    Verify filter-store uses subscribeWithSelector middleware.
    Verify url-sync uses ref guards (isUpdatingFromUrl, isUpdatingFromStore).
    Verify use-filtered-data uses individual primitive selectors (not object selector).
    Verify query-client has staleTime: Infinity.
  </verify>
  <done>
    Filter store manages 4 dimensions with Zustand v5. URL sync bidirectionally syncs filters to URL params. TanStack Query client configured for static data. useFilteredData hook combines cached data with client-side filtering using individual primitive selectors.
  </done>
</task>

</tasks>

<verification>
1. All data loaders import from @data alias and export typed accessor functions
2. Company registry has entries for all 16 companies with getCompanyById working
3. Filter store uses subscribeWithSelector and individual primitive selectors throughout
4. URL sync has ref guards preventing infinite loops
5. Query client has staleTime: Infinity
6. useFilteredData hook filters data in useMemo without triggering re-render loops
7. News loader returns empty array gracefully when no news file exists
8. `npx tsc --noEmit` passes for all files in this plan
</verification>

<success_criteria>
- Data loaders import all 5 JSON files from @data alias with typed interfaces
- News loader filters low-credibility sources and degrades gracefully
- Company registry covers 16 companies with ID/ticker/name lookup
- Filter store is Zustand v5 compatible (subscribeWithSelector, primitive selectors)
- URL sync prevents infinite loops with ref guards
- Query client configured for static presentation data
- useFilteredData hook works with any SectionData type
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md`
</output>
